{"name":"Chess API","tagline":"","body":"#Base.h\r\n\r\n##Color\r\n\r\n> Color opposite(Color c)  \r\n\r\nReturn the opposite color.\r\n\r\n##Piece\r\n\r\n> char letter(Piece p)\r\n\r\nReturn space (empty) or one of PNBRQK.\r\n\r\n##Square\r\n\r\n> Square toSquare(File f, Rank r)\r\n\r\nReturn Square of file f and rank r.\r\n\r\n> File getFile(Square s)  \r\n> Rank getRank(Square s)  \r\n> int fileDist(Square s1, s2)  \r\n> int rankDist(Square s1, s2)  \r\n> int dist(Square s1, s2)  \r\n\r\nReturn the file, rank, and max of (file,rank) distance between squares s1 and s2..\r\n\r\n##Score\r\n\r\n>enum\r\n  minScore = -131072  \r\n  draw = 0  \r\n  pawnValue = 1000  \r\n  mate = 130000  \r\n  illegal = 130100  \r\n  maxScore = +131072  \r\n\r\n#Bitboard.h\r\n\r\n> Bitboard b  &,|,^,~,<<,>>, ==  \r\n> b &= someBB  \r\n> b = b & someBB  \r\n\r\n> Square firstBit(Bitboard b)\r\n\r\nReturns the first 'on' bit in the Bitboard. Used repeatedly to find all the 'on' bits i.e. to locate pieces of type X on bitboard for pieces of type X.\r\n\r\n> int popCount(Bitboard b)\r\n\r\nReturns the number of 'on' bits in the Bitboard i.e. number of pieces of type X\r\n\r\n> void clear(Bitboard& b, Square s)  \r\n> void set(Bitboard& b, Square s)\r\n\r\nClear/set square S on bitboard b.\r\n\r\n#evaluate.h\r\n\r\n> Score evaluate(const Position& pos);\r\n\r\nReturn a score for the position including material and piece positions.\r\n\r\n#Move.h\r\n\r\n## Move class methods\r\n\r\n> Square from()  \r\n> Square to()  \r\n> Piece piece()  \r\n> Piece capture()  \r\n> Piece promote()  \r\n\r\nReturn data associated with the Move.\r\n\r\n# Moves.h\r\n\r\n> void generateMoves(const Position& pos, Moves& moves);\r\n\r\nSave generated moves into moves. Includes illegal moves.\r\n\r\n> void generateNonQuietMoves(const Position& pos, Moves& moves);\r\n\r\nSave generated moves into moves. Includes only captures. (Could be illegal still)\r\n\r\n> Square rotate45Left(Square s);  \r\n> Square rotate45Right(Square s);  \r\n> Square rotate90Left(Square s);  \r\n\r\nRotate a square to match a rotated bitboard.\r\n\r\n> bool isAttacking(Color color, Square s, const Position& pos);\r\n\r\nReturn true if Color color is attacking square S in position pos.\r\n\r\n> Score SEE(const Position &pos, Move move);\r\n\r\nReturn a score based on the result of move in terms of captures & exchanges\r\n\r\n#Position.h\r\n\r\n## Position class methods\r\n\r\n> void makeMove(Move m);  \r\n> void unMakeMove(Move m);  \r\n> void makeNullMove();  \r\n> void unMakeNullMove();  \r\n\r\nMake/unmake a move (or null move for optimizations)\r\n\r\n> void setupFEN(std::string FEN);  \r\n> std::string getFEN() const;\r\n\r\nSet and return string representations of the board.\r\n\r\n> ColoredPiece position[square s] \r\n\r\nReturns the piece and square s\r\n\r\n> BitBoard bitboard(Color c, Piece p) const  \r\nBitBoard occupied(Color c) const  \r\nBitBoard occupied() const  \r\nBitBoard nonOccupied() const  \r\nBitBoard occupiedRotate45Left() const  \r\nBitBoard occupiedRotate45Right() const  \r\nBitBoard occupiedRotate90Left() const  \r\n\r\nReturn various bitboards of certain colors/pieces or rotated/occupied versions.\r\n\r\n> Color turn()  \r\nSquare epSquare()  \r\nCastlingRight castlingRight(Color c)  \r\nScore material(Color c)    \r\nbool inCheck(Color color, const Position& pos)  \r\n\r\nReturn game details such as color, en passant square, castling rights.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}